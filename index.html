<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forge Calculator</title>
    <link rel="stylesheet" href="style.css"> <!-- Link to external CSS -->
</head>

<body>
    <h1>Forge Calculator</h1>

    <div id="oreInputs">
        <div>
            <input type="text" id="name1" placeholder="Ore Name #1">
            <input type="number" id="amt1" placeholder="Amount #1">
        </div>
        <div>
            <input type="text" id="name2" placeholder="Ore Name #2">
            <input type="number" id="amt2" placeholder="Amount #2">
        </div>
        <div>
            <input type="text" id="name3" placeholder="Ore Name #3">
            <input type="number" id="amt3" placeholder="Amount #3">
        </div>
        <div>
            <input type="text" id="name4" placeholder="Ore Name #4">
            <input type="number" id="amt4" placeholder="Amount #4">
        </div>
    </div>

    <br>
    <label for="craft_type">Type:</label>
    <select id="craft_type">
        <option value="Weapon">Weapon</option>
        <option value="Armor">Armor</option>
    </select>

    <br><br>
    <button id="calculateBtn">Calculate</button>

    <h2 id="result"></h2>

    <script>
        let ores = {};
        let weaponOdds = {};
        let armorOdds = {};

        // Load JSON data
        Promise.all([
            fetch("ores.json").then(res => res.json()),
            fetch("weaponOdds.json").then(res => res.json()),
            fetch("armorOdds.json").then(res => res.json())
        ]).then(([oresData, wOdds, aOdds]) => {
            ores = oresData;
            weaponOdds = wOdds;
            armorOdds = aOdds;
        }).catch(err => console.error("Failed to load JSON:", err));

        function calculateCombinedMultiplier(selectedOres) {
            let totalMultiplier = 0;
            let totalCount = 0;
            for (const [oreName, count] of Object.entries(selectedOres)) {
                if (!ores[oreName]) continue;
                totalMultiplier += ores[oreName].multiplier * count;
                totalCount += count;
            }
            return totalCount === 0 ? 0 : totalMultiplier / totalCount;
        }

        function calculateTransferredStat(x) {
            let y = 4.5 * x - 35;
            if (y < 0) y = 0;
            if (y > 100) y = 100;
            return y / 100;
        }

        function getItemChancesWithTraits(selectedOres, craftType = "Weapon") {
            const oddsDict = craftType === "Weapon" ? weaponOdds : armorOdds;
            const combinedMultiplier = calculateCombinedMultiplier(selectedOres);
            const totalCount = Object.values(selectedOres).reduce((a, b) => a + b, 0);
            const MAX_ODDS_ORE_COUNT = 55;
            const oddsKey = totalCount > MAX_ODDS_ORE_COUNT ? MAX_ODDS_ORE_COUNT : totalCount;
            const odds = oddsDict[oddsKey] || oddsDict[Math.max(...Object.keys(oddsDict))];

            const composition = {};
            for (const [ore, count] of Object.entries(selectedOres)) {
                composition[ore] = (count / totalCount * 100);
            }

            const traits = [];
            for (const [ore, pct] of Object.entries(composition)) {
                const oreData = ores[ore];
                if (!oreData || !oreData.trait) continue;

                if (pct >= 10 && (oreData.traitType === craftType || oreData.traitType === "All")) {
                    const transferredFraction = calculateTransferredStat(pct);
                    const maxStat = oreData.trait.maxStat || 0;
                    const traitDesc = oreData.trait.description || oreData.trait;

                    // Only add % if maxStat > 0
                    if (maxStat > 0) {
                        const transferredStat = transferredFraction * maxStat;
                        traits.push(`${transferredStat.toFixed(2)}% ${traitDesc}`);
                    } else {
                        // Just display the description without percentage
                        traits.push(`${traitDesc}`);
                    }
                }
            }


            if (!traits.length) traits.push("No traits transfer");

            const highestOre = Object.entries(composition).reduce((a, b) => b[1] > a[1] ? b : a, ["", 0])[0];
            const rarity = ores[highestOre]?.rarity || "Unknown";

            const sortedOdds = Object.fromEntries(
                Object.entries(odds).filter(([k, v]) => v > 0)
                    .sort((a, b) => b[1] - a[1])
            );

            return {
                combinedMultiplier,
                totalCount,
                composition,
                odds: sortedOdds,
                traits,
                rarity
            };
        }

        document.getElementById("calculateBtn").addEventListener("click", () => {
            const selected = {};
            for (let i = 1; i <= 4; i++) {
                const name = document.getElementById(`name${i}`).value.trim();
                const amt = parseFloat(document.getElementById(`amt${i}`).value);
                if (name && !isNaN(amt) && amt > 0) {
                    selected[name] = amt;
                }
            }

            const craftType = document.getElementById("craft_type").value;
            const totalCount = Object.values(selected).reduce((a, b) => a + b, 0);

            if (totalCount < 3) {
                document.getElementById("result").innerText = "Can't Forge with less than 3 Ores!";
                return;
            }

            const result = getItemChancesWithTraits(selected, craftType);

            let output = "";
            if (totalCount > 55) {
                output += "⚠️ Ore total above 55! Showing stats for 55 ores only. This is not recommended.\n\n";
            }

            output += `Rarity: ${result.rarity}\n`;
            output += `Combined Multiplier: ${result.combinedMultiplier.toFixed(2)}\n\nComposition:\n`;
            for (const [ore, pct] of Object.entries(result.composition)) {
                output += `  ${ore}: ${pct.toFixed(1)}%\n`;
            }

            output += `\nChances:\n`;
            for (const [key, val] of Object.entries(result.odds)) {
                output += `  ${key}: ${(val * 100).toFixed(1)}%\n`;
            }

            output += `\nTraits:\n  ${result.traits.join("\n  ")}`;

            document.getElementById("result").innerText = output;
        });
    </script>
</body>

</html>
